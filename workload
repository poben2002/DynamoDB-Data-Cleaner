import boto3
import time
from collections import defaultdict

# Initialize DynamoDB client
dynamodb = boto3.client("dynamodb", region_name="us-west-2")

TABLE_NAME = "Movies"

# List of tconsts to query
tconst_list = [
    "tt4555672", "tt2330574", "tt29593596", "tt3765568", "tt21141730", "tt0919274",
    "tt13865992", "tt23835448", "tt2681830", "tt10139394", "tt3295656", "tt11193434",
    "tt10715814", "tt27693012", "tt1531936", "tt21408690", "tt1535801", "tt3161404",
    "tt0710036", "tt2462480", "tt4603560", "tt15101938", "tt12452518", "tt14073348",
    "tt2153092", "tt8731048", "tt35192821", "tt3896266", "tt2004146", "tt0838394",
    "tt23131688", "tt10934950", "tt11258328", "tt12211360", "tt26219906", "tt10481574",
    "tt15757910", "tt28980396", "tt14717946", "tt15597848", "tt1788442", "tt21095070",
    "tt30960063", "tt11258344", "tt5433488", "tt21090800", "tt11189680", "tt27511845",
    "tt13658004", "tt15899376", "tt12732556", "tt32262339", "tt2036835", "tt31610832",
    "tt8588986", "tt33317976", "tt9609786", "tt9865546", "tt20784070", "tt0732453",
    "tt3393790", "tt35233386", "tt9750666", "tt27049600", "tt7660134", "tt5732018",
    "tt0065681", "tt8268930", "tt16942430", "tt8458738", "tt4036912", "tt9772504",
    "tt10570734", "tt19852552", "tt0944338", "tt2448512", "tt15997782", "tt11119910",
    "tt8935142", "tt1711559", "tt14061216", "tt13789570", "tt21426152", "tt15262888",
    "tt14686356", "tt8899364", "tt3410788", "tt29543020", "tt15117788", "tt16282994",
    "tt19036110", "tt28960691", "tt6676512", "tt13596436", "tt7922386", "tt3204762",
    "tt0404881", "tt35136976", "tt16372210", "tt6949588"
]

def query_movies_by_tconst():
    """Queries the Movies table for a list of tconsts."""
    results = []
    for tconst in tconst_list:
        response = dynamodb.get_item(
            TableName=TABLE_NAME,
            Key={"tconst": {"S": tconst}}
        )
        if "Item" in response:
            results.append(response["Item"])
    return results

def scan_movies(projection):
    """Scans the Movies table and retrieves only specified attributes."""
    response = dynamodb.scan(
        TableName=TABLE_NAME,
        ProjectionExpression=projection
    )
    return response.get("Items", [])

def group_by_attribute(items, attribute):
    """Groups and counts occurrences of an attribute."""
    count_dict = defaultdict(int)
    for item in items:
        key = item.get(attribute, {}).get("S")
        if key:
            count_dict[key] += 1
    return dict(count_dict)

def get_max(items, attribute):
    """Finds the max value for an attribute."""
    max_value = 0
    max_item = None
    for item in items:
        value = int(item.get(attribute, {}).get("N", 0))
        if value > max_value:
            max_value = value
            max_item = item
    return max_item, max_value

def execute_workload():
    start_time = time.time()

    # Part 1: Query movies by tconst list
    print("Executing Part 1: Query movies by tconst...")
    queried_movies = query_movies_by_tconst()
    print(f"Retrieved {len(queried_movies)} movies.")

    # Part 2: Retrieve startYear and group movies by startYear
    print("Executing Part 2...")
    movies = scan_movies("startYear")
    year_counts = group_by_attribute(movies, "startYear")
    max_year, max_count = max(year_counts.items(), key=lambda x: x[1])
    print(f"Year with most movies: {max_year} ({max_count} movies)")

    # Part 3: Retrieve genres and ratings, group by genre
    print("Executing Part 3...")
    movies = scan_movies("tconst, genres, ratings")
    genre_counts = group_by_attribute(movies, "genres")
    sorted_genres = sorted(genre_counts.items(), key=lambda x: x[1], reverse=True)[:10]
    print("Top 10 genres by movie count:", sorted_genres)

    # Part 4: Retrieve movies from 2014-2024 and calculate avg runtime
    print("Executing Part 4...")
    response = dynamodb.scan(
        TableName=TABLE_NAME,
        ExpressionAttributeNames={"#tt": "titleType", "#sy": "startYear"},
        ExpressionAttributeValues={
            ":type": {"S": "movie"},
            ":start": {"N": "2014"},
            ":end": {"N": "2024"}
        },
        FilterExpression="#tt = :type AND #sy BETWEEN :start AND :end",
        ProjectionExpression="tconst, startYear, titleType, runtimeMinutes"
    )
    movies_2014_2024 = response.get("Items", [])

    year_runtime = defaultdict(list)
    for movie in movies_2014_2024:
        year = movie.get("startYear", {}).get("N")
        runtime = int(movie.get("runtimeMinutes", {}).get("N", 0))
        if year and runtime:
            year_runtime[year].append(runtime)

    avg_runtime_per_year = {year: sum(rt) / len(rt) for year, rt in year_runtime.items()}
    sorted_avg_runtime = sorted(avg_runtime_per_year.items(), key=lambda x: int(x[0]))
    print("Average runtime per year (2014-2024):", sorted_avg_runtime)

    # Part 5: Find the movie with the highest number of votes
    print("Executing Part 5...")
    movies = scan_movies("tconst, primaryTitle, ratings.numVotes")
    max_movie, max_votes = get_max(movies, "ratings.numVotes")
    print(f"Most voted movie: {max_movie.get('primaryTitle', {}).get('S', 'N/A')} with {max_votes} votes")

    end_time = time.time()
    print(f"Total execution time: {end_time - start_time:.2f} seconds")

if __name__ == "__main__":
    execute_workload()
